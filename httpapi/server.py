"""
GitHub App Webhook Server for PR Security Analysis

This server receives GitHub webhook events for pull requests and triggers
security analysis using the PRAnalyzer. Results are posted back to the PR
as comments.
"""

import os
import hmac
import hashlib
import json
import traceback
from flask import Flask, request, jsonify
from threading import Thread
from datetime import datetime
import sys

# Add parent directory to path to import project modules
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from pr_analyzer import PRAnalyzer
from logger import logger
from colorama import Fore
from github import Github


app = Flask(__name__)

# Configuration
WEBHOOK_SECRET = os.environ.get("GITHUB_WEBHOOK_SECRET", "")
GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN", "")
LLM_MODEL = os.environ.get("LLM_MODEL", "o3-mini")
LLM_PROVIDER = os.environ.get("LLM_PROVIDER", "openai")
PORT = int(os.environ.get("PORT", 8080))
HOST = os.environ.get("HOST", "0.0.0.0")

# Initialize GitHub client for posting comments
github_client = Github(GITHUB_TOKEN) if GITHUB_TOKEN else None


def verify_signature(payload_body, signature_header):
    """
    Verify that the payload was sent from GitHub by validating SHA256 signature.
    
    Args:
        payload_body: Raw payload body bytes
        signature_header: X-Hub-Signature-256 header value
        
    Returns:
        bool: True if signature is valid, False otherwise
    """
    if not WEBHOOK_SECRET:
        logger.warning(f"{Fore.YELLOW}No GITHUB_WEBHOOK_SECRET set - skipping signature verification")
        return True
    
    if not signature_header:
        return False
    
    hash_object = hmac.new(
        WEBHOOK_SECRET.encode('utf-8'),
        msg=payload_body,
        digestmod=hashlib.sha256
    )
    expected_signature = "sha256=" + hash_object.hexdigest()
    
    return hmac.compare_digest(expected_signature, signature_header)


def post_pr_comment(owner, repo_name, pr_number, comment_body):
    """
    Post a comment on a GitHub pull request.
    
    Args:
        owner: Repository owner
        repo_name: Repository name
        pr_number: PR number
        comment_body: Comment text to post
    """
    if not github_client:
        logger.error(f"{Fore.RED}Cannot post comment: No GITHUB_TOKEN configured")
        return False
    
    try:
        repo = github_client.get_repo(f"{owner}/{repo_name}")
        pr = repo.get_pull(pr_number)
        pr.create_issue_comment(comment_body)
        logger.info(f"{Fore.GREEN}Posted comment to PR #{pr_number}")
        return True
    except Exception as e:
        logger.error(f"{Fore.RED}Error posting comment: {e}")
        return False


def format_security_report(results):
    """
    Format security analysis results as a GitHub comment.
    
    Args:
        results: Analysis results dictionary
        
    Returns:
        Formatted markdown string for PR comment
    """
    comment = f"""## üîí Security Analysis Report

**PR Title:** {results.get('pr_title', 'N/A')}  
**Analysis Time:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}  
**Files Analyzed:** {results.get('summary', {}).get('files_analyzed', 0)}  
**Total Changes:** {results.get('summary', {}).get('total_changes', 0)} lines

---

### Security Findings

{results.get('security_report', 'No security report generated')}

---

### Detailed Analysis

"""
    
    # Add file-by-file analysis
    for line_analysis in results.get('line_analyses', []):
        filename = line_analysis.get('filename', 'Unknown')
        analysis = line_analysis.get('analysis', 'No analysis available')
        
        comment += f"""
<details>
<summary><b>üìÑ {filename}</b></summary>

```
{analysis}
```

</details>

"""
    
    comment += f"""
---

*Generated by NullKrypt3rs Security Analyzer*  
*Model: {LLM_MODEL} | Provider: {LLM_PROVIDER}*
"""
    
    return comment


def analyze_pr_async(pr_url, owner, repo_name, pr_number):
    """
    Analyze PR asynchronously and post results as a comment.
    
    Args:
        pr_url: Full PR URL
        owner: Repository owner
        repo_name: Repository name
        pr_number: PR number
    """
    try:
        logger.info(f"{Fore.CYAN}Starting async analysis for {pr_url}")
        
        # Post initial comment
        initial_comment = f"""## üîç Security Analysis In Progress

Your PR is being analyzed for security vulnerabilities. This may take a few minutes...

*Analysis started at {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}*
"""
        post_pr_comment(owner, repo_name, pr_number, initial_comment)
        
        # Initialize analyzer
        analyzer = PRAnalyzer(
            pr_url=pr_url,
            llm_model=LLM_MODEL,
            provider=LLM_PROVIDER,
            github_token=GITHUB_TOKEN
        )
        
        # Run analysis
        results = analyzer.analyze()
        
        # Save results
        output_filename = f"pr_{owner}_{repo_name}_{pr_number}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        analyzer.save_results(results, output_filename)
        
        # Format and post results
        comment = format_security_report(results)
        post_pr_comment(owner, repo_name, pr_number, comment)
        
        logger.info(f"{Fore.GREEN}Analysis complete for PR #{pr_number}")
        
    except Exception as e:
        logger.error(f"{Fore.RED}Error analyzing PR: {e}")
        logger.error(traceback.format_exc())
        
        # Post error comment
        error_comment = f"""## ‚ùå Security Analysis Failed

An error occurred while analyzing this PR:

```
{str(e)}
```

Please check the server logs for more details or contact the administrator.

*Error occurred at {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}*
"""
        post_pr_comment(owner, repo_name, pr_number, error_comment)


@app.route("/webhook", methods=["POST"])
def webhook():
    """
    Handle GitHub webhook events for pull requests.
    
    Supported events:
    - pull_request.opened: When a new PR is created
    - pull_request.synchronize: When new commits are pushed to PR
    - pull_request.reopened: When a PR is reopened
    """
    # Verify signature
    signature = request.headers.get("X-Hub-Signature-256")
    if not verify_signature(request.data, signature):
        logger.warning(f"{Fore.RED}Invalid webhook signature")
        return jsonify({"error": "Invalid signature"}), 401
    
    # Get event type
    event_type = request.headers.get("X-GitHub-Event")
    
    logger.info(f"{Fore.CYAN}Received webhook event: {event_type}")
    
    # Parse payload
    try:
        payload = request.json
    except Exception as e:
        logger.error(f"{Fore.RED}Error parsing webhook payload: {e}")
        return jsonify({"error": "Invalid JSON payload"}), 400
    
    # Handle pull request events
    if event_type == "pull_request":
        action = payload.get("action")
        
        # Only analyze on opened, synchronize, or reopened
        if action in ["opened", "synchronize", "reopened"]:
            pr = payload.get("pull_request", {})
            repository = payload.get("repository", {})
            
            pr_number = pr.get("number")
            pr_url = pr.get("html_url")
            owner = repository.get("owner", {}).get("login")
            repo_name = repository.get("name")
            
            logger.info(f"{Fore.GREEN}PR {action}: {pr_url}")
            logger.info(f"{Fore.GREEN}Repository: {owner}/{repo_name}#{pr_number}")
            
            # Trigger analysis in background thread
            thread = Thread(
                target=analyze_pr_async,
                args=(pr_url, owner, repo_name, pr_number)
            )
            thread.daemon = True
            thread.start()
            
            return jsonify({
                "status": "success",
                "message": f"Analysis started for PR #{pr_number}",
                "pr_url": pr_url
            }), 202  # 202 Accepted
        else:
            logger.info(f"{Fore.YELLOW}Ignoring PR action: {action}")
            return jsonify({
                "status": "ignored",
                "message": f"Action '{action}' not configured for analysis"
            }), 200
    
    # Handle ping event (GitHub sends this when webhook is first created)
    elif event_type == "ping":
        logger.info(f"{Fore.GREEN}Webhook ping received - webhook is active!")
        return jsonify({
            "status": "success",
            "message": "Webhook is active and ready to receive events"
        }), 200
    
    # Unknown event type
    else:
        logger.info(f"{Fore.YELLOW}Unsupported event type: {event_type}")
        return jsonify({
            "status": "ignored",
            "message": f"Event type '{event_type}' not supported"
        }), 200


@app.route("/health", methods=["GET"])
def health():
    """
    Health check endpoint.
    
    Returns:
        JSON with server status and configuration
    """
    config_status = {
        "webhook_secret_configured": bool(WEBHOOK_SECRET),
        "github_token_configured": bool(GITHUB_TOKEN),
        "llm_model": LLM_MODEL,
        "llm_provider": LLM_PROVIDER,
    }
    
    return jsonify({
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "config": config_status
    }), 200


@app.route("/", methods=["GET"])
def index():
    """
    Root endpoint with server information.
    """
    return jsonify({
        "name": "NullKrypt3rs GitHub App Webhook Server",
        "description": "Automated security analysis for GitHub pull requests",
        "version": "1.0.0",
        "endpoints": {
            "/webhook": "POST - GitHub webhook endpoint",
            "/health": "GET - Health check",
            "/": "GET - This page"
        },
        "configuration": {
            "llm_model": LLM_MODEL,
            "llm_provider": LLM_PROVIDER,
            "webhook_configured": bool(WEBHOOK_SECRET),
            "github_authenticated": bool(GITHUB_TOKEN)
        }
    }), 200


@app.errorhandler(Exception)
def handle_error(error):
    """
    Global error handler.
    """
    logger.error(f"{Fore.RED}Unhandled error: {error}")
    logger.error(traceback.format_exc())
    
    return jsonify({
        "error": "Internal server error",
        "message": str(error)
    }), 500


def main():
    """
    Start the webhook server.
    """
    # Print configuration
    logger.info(f"{Fore.CYAN}{'='*60}")
    logger.info(f"{Fore.CYAN}NullKrypt3rs GitHub Webhook Server")
    logger.info(f"{Fore.CYAN}{'='*60}")
    logger.info(f"{Fore.GREEN}LLM Model: {LLM_MODEL}")
    logger.info(f"{Fore.GREEN}LLM Provider: {LLM_PROVIDER}")
    logger.info(f"{Fore.GREEN}Webhook Secret: {'Configured' if WEBHOOK_SECRET else 'Not configured (WARNING)'}")
    logger.info(f"{Fore.GREEN}GitHub Token: {'Configured' if GITHUB_TOKEN else 'Not configured (WARNING)'}")
    logger.info(f"{Fore.GREEN}Host: {HOST}")
    logger.info(f"{Fore.GREEN}Port: {PORT}")
    logger.info(f"{Fore.CYAN}{'='*60}")
    
    # Warnings
    if not WEBHOOK_SECRET:
        logger.warning(f"{Fore.YELLOW}WARNING: GITHUB_WEBHOOK_SECRET not set. Webhook signature verification disabled!")
    if not GITHUB_TOKEN:
        logger.warning(f"{Fore.YELLOW}WARNING: GITHUB_TOKEN not set. Cannot post comments to PRs!")
    
    # Start server
    logger.info(f"{Fore.GREEN}Starting server on {HOST}:{PORT}...")
    app.run(host=HOST, port=PORT, debug=False, threaded=True)


if __name__ == "__main__":
    main()

